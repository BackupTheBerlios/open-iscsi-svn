diff -Naurp open-iscsi.diffbase/kernel/iscsi_compat.h open-iscsi.test/kernel/iscsi_compat.h
--- open-iscsi.diffbase/kernel/iscsi_compat.h	1969-12-31 18:00:00.000000000 -0600
+++ open-iscsi.test/kernel/iscsi_compat.h	2006-01-16 17:50:27.000000000 -0600
@@ -0,0 +1,69 @@
+/*
+ * compat crap for older kernels.
+ * do not send to linux-scsi
+ */
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_host.h>
+
+#ifndef DEFINE_MUTEX
+
+/* mutex changes from 2.6.16-rc1 and up */
+#define DEFINE_MUTEX DECLARE_MUTEX
+#define mutex_lock down
+#define mutex_unlock up
+#define mutex semaphore
+#define mutex_init init_MUTEX
+#endif
+
+#if LINUX_VERSION_CODE == KERNEL_VERSION(2,6,11)
+
+#define transport_container_register attribute_container_register
+#define transport_container_unregister attribute_container_unregister
+#define transport_container attribute_container
+
+void scsi_queue_work(struct Scsi_Host *shost, struct work_struct *work)
+{
+	schedule_work(work);
+}
+
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,12)
+
+void int_to_scsilun(unsigned int lun, struct scsi_lun *scsilun)
+{
+	int i;
+
+	memset(scsilun->scsi_lun, 0, sizeof(scsilun->scsi_lun));
+
+	for (i = 0; i < sizeof(lun); i += 2) {
+		scsilun->scsi_lun[i] = (lun >> 8) & 0xFF;
+		scsilun->scsi_lun[i+1] = lun & 0xFF;
+		lun = lun >> 16;
+	}
+}
+
+#define __nlmsg_put(skb, daemon_pid, seq, type, len, flags) \
+	__nlmsg_put(skb, daemon_pid, 0, 0, len)
+
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,13)
+
+#define netlink_kernel_create(uint, groups, input, mod) \
+	netlink_kernel_create(uint, input)
+
+#define gfp_t unsigned
+
+void *kzalloc(size_t size, gfp_t flags)
+{
+	void *ret = kmalloc(size, flags);
+	if (ret)
+		memset(ret, 0, size);
+	return ret;
+}
+
+#endif
+
diff -Naurp open-iscsi.diffbase/kernel/iscsi_tcp.c open-iscsi.test/kernel/iscsi_tcp.c
--- open-iscsi.diffbase/kernel/iscsi_tcp.c	2006-01-16 15:38:52.000000000 -0600
+++ open-iscsi.test/kernel/iscsi_tcp.c	2006-01-16 17:40:10.000000000 -0600
@@ -33,7 +33,6 @@
 #include <linux/delay.h>
 #include <linux/kfifo.h>
 #include <linux/scatterlist.h>
-#include <linux/mutex.h>
 #include <net/tcp.h>
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
@@ -44,6 +43,7 @@
 #include <scsi/scsi.h>
 #include "scsi_transport_iscsi.h"
 
+#include "iscsi_compat.h"
 #include "iscsi_tcp.h"
 
 MODULE_AUTHOR("Dmitry Yusupov <dmitry_yus@yahoo.com>, "
@@ -2948,11 +2948,13 @@ iscsi_eh_host_reset(struct scsi_cmnd *sc
 	struct iscsi_conn *conn = ctask->conn;
 	struct iscsi_session *session = conn->session;
 
+	spin_unlock_irq(session->host->host_lock);
 	spin_lock_bh(&session->lock);
 	if (session->state == ISCSI_STATE_TERMINATE) {
 		debug_scsi("failing host reset: session terminated "
 			   "[CID %d age %d]", conn->id, session->age);
 		spin_unlock_bh(&session->lock);
+		spin_lock_irq(session->host->host_lock);
 		return FAILED;
 	}
 	spin_unlock_bh(&session->lock);
@@ -2962,6 +2964,7 @@ iscsi_eh_host_reset(struct scsi_cmnd *sc
 		   session->age);
 	iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
 
+	spin_lock_irq(session->host->host_lock);
 	return SUCCESS;
 }
 
@@ -2996,6 +2999,7 @@ iscsi_eh_abort(struct scsi_cmnd *sc)
 	conn->eh_abort_cnt++;
 	debug_scsi("aborting [sc %lx itt 0x%x]\n", (long)sc, ctask->itt);
 
+	spin_unlock_irq(session->host->host_lock);
 	/*
 	 * two cases for ERL=0 here:
 	 *
@@ -3164,6 +3168,8 @@ exit:
 		write_unlock_bh(&sk->sk_callback_lock);
 	}
 	mutex_unlock(&conn->xmitmutex);
+
+	spin_lock_irq(session->host->host_lock);
 	return rc;
 }
 
diff -Naurp open-iscsi.diffbase/kernel/scsi_transport_iscsi.c open-iscsi.test/kernel/scsi_transport_iscsi.c
--- open-iscsi.diffbase/kernel/scsi_transport_iscsi.c	2006-01-16 15:38:52.000000000 -0600
+++ open-iscsi.test/kernel/scsi_transport_iscsi.c	2006-01-16 17:53:34.000000000 -0600
@@ -22,7 +22,6 @@
  */
 #include <linux/module.h>
 #include <linux/mempool.h>
-#include <linux/mutex.h>
 #include <net/tcp.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_host.h>
@@ -30,6 +29,7 @@
 #include <scsi/scsi_transport.h>
 #include "scsi_transport_iscsi.h"
 #include "iscsi_if.h"
+#include "iscsi_compat.h"
 
 #define ISCSI_SESSION_ATTRS 8
 #define ISCSI_CONN_ATTRS 6
@@ -379,7 +379,6 @@ iscsi_transport_create_session(struct sc
 	shost->max_lun = transport->max_lun;
 	shost->max_cmd_len = transport->max_cmd_len;
 	shost->transportt = scsit;
-	shost->transportt->create_work_queue = 1;
 
 	if (scsi_add_host(shost, NULL))
 		goto free_host;
@@ -447,7 +446,7 @@ static inline struct list_head *skb_to_l
 }
 
 static void*
-mempool_zone_alloc_skb(unsigned int gfp_mask, void *pool_data)
+mempool_zone_alloc_skb(int gfp_mask, void *pool_data)
 {
 	struct mempool_zone *zone = pool_data;
 
@@ -999,10 +998,10 @@ static int iscsi_session_match(struct at
 		return 0;
 
 	priv = to_iscsi_internal(shost->transportt);
-	if (priv->session_cont.ac.class != &iscsi_session_class.class)
+	if (priv->session_cont.class != &iscsi_session_class.class)
 		return 0;
 
-	return &priv->session_cont.ac == cont;
+	return &priv->session_cont == cont;
 }
 
 static int iscsi_conn_match(struct attribute_container *cont,
@@ -1024,10 +1023,10 @@ static int iscsi_conn_match(struct attri
 		return 0;
 
 	priv = to_iscsi_internal(shost->transportt);
-	if (priv->conn_cont.ac.class != &iscsi_connection_class.class)
+	if (priv->conn_cont.class != &iscsi_connection_class.class)
 		return 0;
 
-	return &priv->conn_cont.ac == cont;
+	return &priv->conn_cont == cont;
 }
 
 struct scsi_transport_template *
@@ -1074,9 +1073,9 @@ iscsi_register_transport(struct iscsi_tr
 	}
 
 	/* connection parameters */
-	priv->conn_cont.ac.attrs = &priv->conn_attrs[0];
-	priv->conn_cont.ac.class = &iscsi_connection_class.class;
-	priv->conn_cont.ac.match = iscsi_conn_match;
+	priv->conn_cont.attrs = &priv->conn_attrs[0];
+	priv->conn_cont.class = &iscsi_connection_class.class;
+	priv->conn_cont.match = iscsi_conn_match;
 	transport_container_register(&priv->conn_cont);
 
 	SETUP_CONN_RD_ATTR(max_recv_dlength, ISCSI_PARAM_MAX_RECV_DLENGTH);
@@ -1091,9 +1090,9 @@ iscsi_register_transport(struct iscsi_tr
 	count = 0;
 
 	/* session parameters */
-	priv->session_cont.ac.attrs = &priv->session_attrs[0];
-	priv->session_cont.ac.class = &iscsi_session_class.class;
-	priv->session_cont.ac.match = iscsi_session_match;
+	priv->session_cont.attrs = &priv->session_attrs[0];
+	priv->session_cont.class = &iscsi_session_class.class;
+	priv->session_cont.match = iscsi_session_match;
 	transport_container_register(&priv->session_cont);
 
 	SETUP_SESSION_RD_ATTR(initial_r2t, ISCSI_PARAM_INITIAL_R2T_EN);
