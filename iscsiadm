#!/usr/bin/perl
#
# iSCSI Configuration Utility
# Copyright (C) 2004 Dmitry Yusupov, Alex Aizman
# maintained by simple-iscsi-devel@lists.sourceforge.net
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# See the file COPYING included with this distribution for more details.
#

use Cwd;
use Getopt::Std;
use Socket;
use strict;

use vars qw/ %opt /;
my $reopen_attempts = 0;
my $reopen_timeout = 3;
my $recv_timeout = 5;
my $sysfs_path = "/sys/class/iscsi";

#
# Default Configuration
#
my $initiator_name = "iqn.com.dima";
my $initiator_alias = "dima-um";
my @isid = ('0', '1', '2', '3', '4', '5');
my $first_burst = 262144;
my $max_recv_dlength = 65536;
my $max_burst = 262144;
my $max_r2t = 1;
my $max_cnx = 1;
my $erl = 0;
my $initial_r2t_en = 0;
my $imm_data_en  = 1;
my $hdrdgst_en = 0;
my $datadgst_en = 0;
my $ifmarker_en = 0;
my $ofmarker_en = 0;
my $pdu_inorder_en = 1;
my $dataseq_inorder_en = 1;
my $time2wait = 5;
my $time2retain = 20;
my $auth_en = 0;
my $cmdsn = 1;

#
# Response Configuration
#
my $target_name;
my $target_portal;
my $target_alias;
my $target_address;
my $tpgt;
my $max_xmit_dlength = 8192;
my $tsih = 0;
my $exp_cmdsn;
my $max_cmdsn;

my $iscsiadm_path;

sub fatal {
	print "iscsiadm: @_", "\n";
	exit;
}

$SIG{ALRM} = sub {
	fatal("recv timeout");
};

sub iscsi_open {
	my ($attr, $op) = @_;
	open(my $fd, "$attr$sysfs_path/$op") ||
		fatal("iSCSI driver is not loaded");
	return $fd;
}

#
# Retrieve string with the length of padding filled in
# by zeroes.
#
sub padding {
	my ($dlength) = @_;
	my $pad = "";
	if ($dlength%4 != 0) { $pad = "\0" x (4 - $dlength%4); }
	return $pad;
}

#
# Send Login PDU
#
sub send_login_req {
	my ($cmdsn, $exp_statsn, $flags, $cid, $data) = @_;
	my $dlength = length($data);
	my $loginpdu = pack('CCCCCCCCccccccnNnccNNNNNN',
		    0x43,			# C: opcode: Login + Immediate
		    0x87,			# C: flags T, OP, FF
		    0,				# C: max ver
		    0,				# C: min ver
		    0,				# C: hlength
		    ($dlength >> 16) & 0xFF,	# C: byte 0 of dlength
		    ($dlength >> 8) & 0xFF,	# C: byte 1 of dlength
		    $dlength & 0xFF,		# C: byte 2 of dlength
		    @isid[0],@isid[1],@isid[2],@isid[3],@isid[4],@isid[5],
						# cccccc: isid
		    $tsih,			# n: tsih
		    0,				# N: itt
		    $cid,			# n: cid
		    0,0,			# cc: rsvd2
		    $cmdsn,			# N: cmdsn
		    $exp_statsn,		# N: exp_statsn
		    0,0,0,0			# NNNN: rsvd16
		    );
	print SOCK $loginpdu.$data.padding($dlength);
}

#
# Send Text PDU
#
sub send_text_req {
	my ($cmdsn, $exp_statsn, $ttt, $data) = @_;
	my $dlength = length($data);
	my $textpdu = pack('CCsCCCCNNNNNNNNNN',
		    0x4,			# C: opcode: Text
		    0x80,			# C: flags F
		    0,				# s: rsvd2
		    0,				# C: hlength
		    ($dlength >> 16) & 0xFF,	# C: byte 0 of dlength
		    ($dlength >> 8) & 0xFF,	# C: byte 1 of dlength
		    $dlength & 0xFF,		# C: byte 2 of dlength
		    0,				# N: rsvd4
		    0,				# N: rsvd4
		    0,				# N: itt
		    $ttt,			# N: ttt
		    $cmdsn,			# N: cmdsn
		    $exp_statsn,		# N: exp_statsn
		    0,0,0,0			# NNNN: rsvd16
		    );
	print SOCK $textpdu.$data.padding($dlength);
}

sub recv_pdu {
	my ($len) = @_;
	alarm($recv_timeout);
	read(SOCK, my $rsp, $len)==$len || fatal("bad length response ($len)");
	alarm(0);
	return $rsp;
}

sub login_text_rsp_parse {
	my $data = "";
	my ($rsp) = @_;

	my @pairs = split(/\0/, $rsp);
	my $i = 0;
	while (@pairs[$i]) {
		$data = $data."\0" if $i != 0;
		if (@pairs[$i] =~ /^TargetAlias=(.*)/) {
			$target_alias = $1;
			$data = $data.@pairs[$i];
		} elsif (@pairs[$i] =~ /^TargetAddress=(.*)/) {
			$target_address = $1;
			fatal("redirection is not supported");
		} elsif (@pairs[$i] =~ /^TargetPortalGroupTag=(.*)/) {
			$tpgt = $1;
			$data = $data.@pairs[$i];
		} elsif (@pairs[$i] =~ /^InitialR2T=(.*)/) {
			$initial_r2t_en = ($1 eq "Yes"?1:0);
			$data = $data.@pairs[$i];
		} elsif (@pairs[$i] =~ /^ImmediateData=(.*)/) {
			$imm_data_en = ($1 eq "Yes"?1:0);
			$data = $data.@pairs[$i];
		} elsif (@pairs[$i] =~ /^MaxRecvDataSegmentLength=(.*)/) {
			$max_xmit_dlength = $1;
			$data = $data.@pairs[$i];
		} elsif (@pairs[$i] =~ /^FirstBurstLength=(.*)/) {
			$first_burst = $1;
			$data = $data.@pairs[$i];
		} elsif (@pairs[$i] =~ /^MaxBurstLength=(.*)/) {
			$max_burst = $1;
			$data = $data.@pairs[$i];
		} elsif (@pairs[$i] =~ /^HeaderDigest/) {
			$data = $data."HeaderDigest=None";
		} elsif (@pairs[$i] =~ /^DataDigest/) {
			$data = $data."DataDigest=None";
		} elsif (@pairs[$i] =~ /^DefaultTime2Wait=(.*)/) {
			$time2wait = $1;
			$data = $data.@pairs[$i];
		} elsif (@pairs[$i] =~ /^DefaultTime2Retain=(.*)/) {
			$time2retain = $1;
			$data = $data.@pairs[$i];
		} elsif (@pairs[$i] =~ /^MaxOutstandingR2T=(.*)/) {
			$max_r2t = $1;
			$data = $data.@pairs[$i];
		} elsif (@pairs[$i] =~ /^MaxConnections=(.*)/) {
			fatal("max connections rsp error") if $1 > $max_cnx;
		} elsif (@pairs[$i] =~ /^ErrorRecoveryLevel=(.*)/) {
			fatal("recovery level rsp error")
					if $1 != $erl;
		} elsif (@pairs[$i] =~ /^OFMarker=(.*)/) {
			# ignoring...
		} elsif (@pairs[$i] =~ /^OFMarkInt=(.*)/) {
			# ignoring...
		} elsif (@pairs[$i] =~ /^IFMarker=(.*)/) {
			# ignoring...
		} elsif (@pairs[$i] =~ /^IFMarkInt=(.*)/) {
			# ignoring...
		} elsif (@pairs[$i] =~ /^DataPDUInOrder=(.*)/) {
			# ignoring...
		} elsif (@pairs[$i] =~ /^DataSequenceInOrder=(.*)/) {
			# ignoring...
		}
		$i++;
	}
	return $data;
}

#
# Do SendTargets discovery, on good result either automaticaly
# login or just show the result
#
sub sendtargets_discovery {
	my ($callback, $ipaddr_port) = @_;
	my $rsp;
	my $dlength;
	my $ipaddr;
	my $port;
	if ($ipaddr_port =~ /^([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+):([0-9]+)$/) {
		$ipaddr = $1;
		$port = $2;
	} else {
		fatal("bad discovery format: $ipaddr_port, ".
		      "expecting <ipaddr>:<port>");
	}

	socket(SOCK, PF_INET, SOCK_STREAM,
	       getprotobyname('tcp')) || fatal("socket: $!");
	connect(SOCK, sockaddr_in($port,
			  inet_aton($ipaddr))) || fatal("connect: $!");
	select(SOCK); $| = 1; select(STDOUT);    # use unbuffemiles i/o.

	my $cmdsn = 1;
	my $exp_statsn = 1;
	my $data = "InitiatorName=$initiator_name\0SessionType=Discovery";
	while(1) {
		send_login_req($cmdsn, $exp_statsn, 0x87, 0, $data);
		$rsp = recv_pdu(48);
		my ($opcode, $flags, $junk, $len0, $len1, $len2, $junk,
			$statsn, $junk, $class, $detail, $junk) =
			unpack('CCa3CCCa16Na8CCa*', $rsp);
		$opcode == 0x23 || fatal("bad login_rsp opcode ($opcode)");
		$dlength = (($len0 << 16) | ($len1 << 8) | $len2);
		if ($dlength%4 != 0) { $dlength += 4 - $dlength%4 };
		$rsp = recv_pdu($dlength);

		$class == 1 && fatal("redirection is not supported ($detail)");
		$class == 2 && fatal("initiator error ($detail)");
		$class == 3 && fatal("target error ($detail)");

		#
		# stop if T-bit is set
		#
		last if ($flags & 0x80);

		$data = login_text_rsp_parse($rsp);
		$exp_statsn = $statsn + 1;
	}

	my $ttt = 0xffffffff;
	my $i=0;
	my $data = "SendTargets=All\0";
	while(1) {
		send_text_req($cmdsn++, $exp_statsn, $ttt, $data);
		my $rsp = recv_pdu(48);
		my ($opcode, $flags, $junk, $len0, $len1, $len2, $junk,
			$ttt, $statsn, $junk) = unpack('CCa3CCCa12NNa*', $rsp);
		$opcode == 0x24 || fatal("bad text_rsp opcode ($opcode)");
		$dlength = (($len0 << 16) | ($len1 << 8) | $len2);
		if ($dlength%4 != 0) { $dlength += 4 - $dlength%4; }

		#
		# read & parse Text's DataSegment
		#
		$rsp = recv_pdu($dlength);
		if ($rsp =~ /.*TargetName=(.*)\0TargetAddress=(.*)\0/) {
		       $target_name = $1;
		       $target_portal = $2;
		} elsif ($rsp =~ /.*TargetAddress=(.*)\0TargetName=(.*)\0/) {
		       $target_portal = $1;
		       $target_name = $2;
		} else { last; }

		&$callback($i++, $target_name, $target_portal);

		#
		# stop if T-bit is set
		#
		last if ($flags & 0x80);

		$exp_statsn = $statsn + 1;
	};

	close(SOCK);
}

#
# Do Login request, auth, parameters negotiation. On success,
# transfer connection to the kernel.
#
sub connection_login {
	my ($target_name, $target_portal, $cid) = @_;
	my $rsp;
	my $dlength;
	my $ipaddr;
	my $port;
	if ($target_portal =~
		/^([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+):([0-9]+),([0-9]+).*$/) {
		$ipaddr = $1;
		$port = $2;
		$tpgt = $3;
	} else {
		print "bad target portal format: $target_portal, ".
		      "expecting <ipaddr>:<port>,<tpgt>";
		return 0;
	}

	socket(SOCK, PF_INET, SOCK_STREAM, getprotobyname('tcp')) ||
				printf("socket: $!\n") && return 0;
	setsockopt(SOCK, SOL_SOCKET, SO_SNDBUF, 500*1024);
	setsockopt(SOCK, SOL_SOCKET, SO_RCVBUF, 500*1024);
	connect(SOCK, sockaddr_in($port, inet_aton($ipaddr))) ||
				printf("connect: $!") && return 0;
	select(SOCK); $| = 1; select(STDOUT);    # use unbuffemiles i/o.

	my $exp_statsn = 1;
	my $data;
	my $data_initial;
	my $flags;
	my $c_stage = -1;
	my $n_stage = -1;
	my $transit = 0;
	my $partial_rsp = 0;
	do {
		if ($c_stage == -1) {
			$data_initial = "InitiatorName=$initiator_name\0".
					"InitiatorAlias=$initiator_alias\0".
					"TargetName=$target_name\0".
					"SessionType=Normal" if $cid == 0;
			if ($auth_en) {
				# we're prepared to do authentication
				$c_stage = $n_stage = 0;
			} else {
				# can't do any authentication, skip that
				# stage
				$c_stage = $n_stage = 1;
			}
		}

		if ($c_stage == 0) {
			# negotiate security...
			# to be done...
		} elsif ($c_stage == 1) {
			$n_stage = 3;
			$transit = 1;
			if (!$partial_rsp) {
				$data = $data_initial."\0".
		        "HeaderDigest=".($hdrdgst_en?"CRC32C,None":"None")."\0".
		        "DataDigest=".($datadgst_en?"CRC32C,None":"None")."\0".
		        "MaxRecvDataSegmentLength=$max_recv_dlength\0".
		        "InitialR2T=".($initial_r2t_en?"Yes":"No")."\0".
		        "ImmediateData=".($imm_data_en?"Yes":"No")."\0".
		        "MaxBurstLength=$max_burst\0".
		        "FirstBurstLength=$first_burst\0".
		        "DefaultTime2Wait=$time2wait\0".
		        "DefaultTime2Retain=$time2retain\0".
		        "MaxOutstandingR2T=$max_r2t\0".
		        "MaxConnections=$max_cnx\0".
		        "ErrorRecoveryLevel=$erl\0".
		        "IFMarker=".($ifmarker_en?"Yes":"No")."\0".
		        "OFMarker=".($ofmarker_en?"Yes":"No")."\0".
		        "DataPDUInOrder=".($pdu_inorder_en?"Yes":"No")."\0".
		        "DataSequenceInOrder=".
				($dataseq_inorder_en?"Yes":"No") if $cid == 0;
				$data = 
		        "HeaderDigest=".($hdrdgst_en?"CRC32C,None":"None")."\0".
		        "DataDigest=".($datadgst_en?"CRC32C,None":"None")."\0".
			"MaxRecvDataSegmentLength=".
					"$max_recv_dlength\0" if $cid != 0;
			}
		}

		# fill in the flags
		$flags = 0;
		$flags |= $c_stage << 2;
		if ($transit) {
			# transit to the next stage
			$flags |= $n_stage;
			$flags |= 0x80;
		} else {
			# next == current
			$flags |= $c_stage;
		}
		send_login_req($cmdsn, $exp_statsn, $flags, $cid, $data);
		$rsp = recv_pdu(48);
		my ($opcode, $flags, $vmax, $vactive,
                    $junk, $len0, $len1, $len2, $junk, $_tsih, $junk,
		    $statsn, $_exp_cmdsn, $_max_cmdsn, $class, $detail, $junk) =
			unpack('CCCCa1CCCa6na8NNNCCa*', $rsp);
		$opcode == 0x23 ||
			printf("bad login_rsp opcode ($opcode)\n") && return 0;
		$dlength = (($len0 << 16) | ($len1 << 8) | $len2);
		if ($dlength%4 != 0) { $dlength += 4 - $dlength%4 };
		$rsp = recv_pdu($dlength);

		$class == 1 &&
			printf("redirection is not supported ($detail)\n") &&
				return 0;
		$class == 2 && printf("initiator error ($detail)\n") &&
					return 0;
		$class == 3 && printf("target error ($detail)\n") && return 0;

		$vactive != 0 && fatal("version mismatch");

		# make sure the current stages matches
		$c_stage != (($flags & 0x0C)>>2) &&
			printf("protocol error: current stage not matches\n") &&
				return 0;	

		# make sure that we're actually advancing if the
		# T-bit is set
                $transit && (($flags & 0x03) <= $c_stage) &&
		    fatal("protocol error: next stage is not advancing\n") &&
			return 0;

		if ($c_stage == 0) {
			# to be implemented...
		} elsif ($c_stage == 1) {
			$data = login_text_rsp_parse($rsp);
		}

		if ($transit) {
			# advance to the next stage
			$partial_rsp = 0;
			$c_stage = $flags & 0x3;
		} else {
			# we got a partial response, don't advance,
			# more negotiation to do
			$partial_rsp = 1;
		}

		# record some fields for later use
		$tsih = $_tsih;
		$max_cmdsn = $_max_cmdsn;
		$exp_cmdsn = $_exp_cmdsn;
		$exp_statsn = $statsn + 1;
	} while ($c_stage != 3);

	return fileno(SOCK);
}

sub get_session_ids {
	opendir(DIR, $sysfs_path);
	my @ids = grep(s/^host([0-9]+)$/\1/,readdir(DIR));
	closedir(DIR);
	return @ids;
}

sub getstate {
	my ($id) = @_;
	my $fd;

	$fd = iscsi_open("<", "host$id/state");
	chop(my @state = <$fd>);
	close($fd);
	return $state[0];
}

sub getparam {
	my ($id, $param) = @_;
	my $fd;

	if ($id == -1) {
		$fd = iscsi_open("<", "initiator_parameters");
	} else {
		$fd = iscsi_open("<", "host$id/parameters");
	}
	my @lines = <$fd>;
	close($fd);
	foreach my $line (@lines) {
		if ($line =~ /^$param.*=(.*)$/) {
			$line = $1;
			$line =~ s/^\s+|\s+$//g;
			return $line;
		}
	}
	fatal("not existing parameter '$param'!");
}

sub show_sessions {
	my @ids = get_session_ids();

	if (length(@ids) == 0) {
		printf "Active iSCSI Sessions: none\n";
	} else {
		printf "Active iSCSI Sessions:\n";
		foreach my $id (sort @ids) {
			my $state = getstate($id);
			printf("#%d %s ($state)\n",
			        $id, getparam($id, "target_name"));
		}
	}
}

sub setparam {
	my ($id, $param, $value) = @_;
	my $fd;

	if ($id == -1) {
		$fd = iscsi_open(">", "initiator_parameters");
	} else {
		$fd = iscsi_open(">", "host$id/parameters");
	}
	print $fd "$param $value";
	close($fd);
}

sub operation {
	my ($str) = @_;
	my $fd = iscsi_open(">", "session_operation");
	if (syswrite($fd, "$str") == 0) {
		close($fd);
		printf("iscsiadm: unsuccessful operation: '$str'\n");
		return 0;
	}
	close($fd);
	return 1;
}

sub logout {
	my ($sid) = @_;
	operation("tcp connection remove $sid 0") || exit 1;
	operation("tcp session remove $sid") || exit 1;
}

sub sysfs_save {
	setparam(-1, "initiator_name", $initiator_name);
	setparam(-1, "initiator_alias", $initiator_alias);
	setparam(-1, "isid", @isid);
	setparam(-1, "target_name", $target_name);
	setparam(-1, "target_alias", $target_name);
	setparam(-1, "target_portal", $target_portal);
	setparam(-1, "target_address", $target_portal);
	setparam(-1, "tpgt", $tpgt);
	setparam(-1, "first_burst", $first_burst);
	setparam(-1, "max_recv_dlength", $max_recv_dlength);
	setparam(-1, "max_xmit_dlength", $max_xmit_dlength);
	setparam(-1, "max_burst", $max_burst);
	setparam(-1, "max_r2t", $max_r2t);
	setparam(-1, "max_cnx", $max_cnx);
	setparam(-1, "erl", $erl);
	setparam(-1, "initial_r2t_en", $initial_r2t_en);
	setparam(-1, "imm_data_en", $imm_data_en);
	setparam(-1, "hdrdgst_en", $hdrdgst_en);
	setparam(-1, "datadgst_en", $datadgst_en);
	setparam(-1, "ifmarker_en", $ifmarker_en);
	setparam(-1, "ofmarker_en", $ofmarker_en);
	setparam(-1, "pdu_inorder_en", $pdu_inorder_en);
	setparam(-1, "dataseq_inorder_en", $dataseq_inorder_en);
	setparam(-1, "time2wait", $time2wait);
	setparam(-1, "time2retain", $time2retain);
	setparam(-1, "auth_en", $auth_en);
	setparam(-1, "cmdsn", $cmdsn);
	setparam(-1, "exp_cmdsn", $exp_cmdsn);
	setparam(-1, "max_cmdsn", $max_cmdsn);
	setparam(-1, "tsih", $tsih);
}

sub sysfs_restore {
	my ($id) = @_;

	$initiator_name = getparam(-1, "initiator_name");
	$initiator_alias = getparam(-1, "initiator_alias");
	@isid = getparam($id, "isid");
	$tsih = getparam($id, "tsih");
	$target_name = getparam($id, "target_name");
	$target_alias = getparam($id, "target_alias");
	$target_portal = getparam($id, "target_portal");
	$target_address = getparam($id, "target_address");
	$tpgt = getparam($id, "tpgt");
	$first_burst = getparam($id, "first_burst");
	$max_burst = getparam($id, "max_burst");
	$max_r2t = getparam($id, "max_r2t");
	$max_cnx = getparam($id, "max_cnx");
	$erl = getparam($id, "erl");
	$initial_r2t_en = getparam($id, "initial_r2t_en");
	$imm_data_en = getparam($id, "imm_data_en");
	$ifmarker_en = getparam($id, "ifmarker_en");
	$ofmarker_en = getparam($id, "ofmarker_en");
	$pdu_inorder_en = getparam($id, "pdu_inorder_en");
	$dataseq_inorder_en = getparam($id, "dataseq_inorder_en");
	$time2wait = getparam($id, "time2wait");
	$time2retain = getparam($id, "time2retain");

	#$max_recv_dlength = getparam($id, "max_recv_dlength");
	#$max_xmit_dlength = getparam($id, "max_xmit_dlength");
	#$hdrdgst_en = getparam($id, "hdrdgst_en");
	#$datadgst_en = getparam($id, "datadgst_en");
}

sub add_conn {
	my ($sid) = @_;
}

############################## end of library #################################

sub discovery_list_cb {
	my ($id, $target_name, $target_portal) = @_;
	printf "#%d %s [%s]\n", $id, $target_name, $target_portal;
}

sub discovery_login_cb {
	my ($id, $target_name, $target_portal) = @_;
	my $cnx_cnt = 0;
	my $sid;

	do {
		my $sock_fd = connection_login($target_name,
					$target_portal, $cnx_cnt);
		if ($sock_fd) {
			if ($cnx_cnt == 0) { # leading connection
				sysfs_save();
				my @sids = get_session_ids();
				my ($min,$max)=(sort @sids)[0,-1];
				$sid = ++$max;
				operation("tcp session add $sid") || exit 1;
			}
			operation("tcp connection add $sid ".
				  "$cnx_cnt $sock_fd") || exit 1;
			require 'sys/syscall.ph';
			syscall(&SYS_close, $sock_fd + 0);
		}
	} while (++$cnx_cnt < $max_cnx);
}

sub try_reopen {
	my ($id) = @_;
	my $sock_fd;

	sysfs_restore($id);
	$sock_fd = connection_login($target_name, $target_portal, 0);
	if ($sock_fd) {
		sysfs_save();
		my $res = operation("tcp connection add $id 0 $sock_fd");
		require 'sys/syscall.ph';
		syscall(&SYS_close, $sock_fd + 0);
		return $res;
	}
	return 0;
}

sub usage {
print STDERR << "EOF";

iSCSI Configuration Utility

	usage: iscsiadm [-hv] [-f file] [-d addr:port] [-r id]

	-h            : this (help) message
	-v            : verbose output
	-f file       : file containing configuration, using /etc/iscsi.conf
	                if omited
	-d addr:port  : SendTargets method IP-address and port
	-c sid:cid    : Add one more connection 'cid' to the session 'sid'
	-r sid[:cid]  : Logout and remove iSCSI session specified by 'sid'
	                and all connections. Or remove only connection
	                specified by 'cid'
	-a            : process hotplug events

	example: iscsiadm -f /mypath/my.conf 127.0.0.1:3260

EOF
exit;
}

sub init() {
	my $opt_string = 'hvr:d:f:ac:';
	getopts( "$opt_string", \%opt ) or usage();
	usage() if $opt{h};
	$iscsiadm_path = $0;
	if ($iscsiadm_path =~ /^\.(.*)$/) {
		$iscsiadm_path = cwd . $1;
	}
}

sub hotplug_agent_check() {
	if (! -x "/etc/hotplug/iscsi.agent") {
		open(FH,">/etc/hotplug/iscsi.agent");
		print FH "#!/bin/sh
#
# Generated by iscsiadm
#
# iSCSI hotplug agent for 2.6 kernels
#
# Example of event:
#
#       PHYSDEVPATH=/devices/platform/host23
#       SUBSYSTEM=iscsi
#       DEVPATH=/class/iscsi/host2
#       PATH=/sbin:/bin:/usr/sbin:/usr/bin
#       ACTION=change
#

cd /etc/hotplug
. ./hotplug.functions

ISCSIADM=$iscsiadm_path

case \$ACTION in

change)
        \$ISCSIADM -a
        ;;

*)
        debug_mesg \"iSCSI \$ACTION event not supported\"
        exit 1
        ;;

esac
";
		close(FH);
		chmod(0755, "/etc/hotplug/iscsi.agent");
	}
}

sub hotplug_event() {
	if ($ENV{"SUBSYSTEM"} eq "iscsi" &&
	    $ENV{"ACTION"} eq "change" &&
	    $ENV{"DEVPATH"} =~ /^\/class\/iscsi\/host([0-9]+)$/) {
		my $cnt = $reopen_attempts;
		while($cnt) {
			last if try_reopen($1);
			sleep($reopen_timeout);
			--$cnt if $cnt != -1;
		}
		exit 0;
	} else {
		fatal("not recognized hotplug event!");
	}
}

################################  main program ################################

init();
hotplug_agent_check();
if ($opt{f}) {
	#
	# Read Configuration
	#
	printf "not implemented\n";
}
if ($opt{a}) {
	hotplug_event();
}
if (defined($opt{r})) {
	logout($opt{r});
	exit;
}
if (defined($opt{c})) {
	add_conn($opt{c});
	exit;
}
if ($opt{v}) {
	if ($opt{d}) {
		#
		# Do SendTargets method discovery (verbose)
		#
		sendtargets_discovery(\&discovery_list_cb, $opt{d});
	} else {
		usage();
	}
} else {
	if ($opt{d}) {
		#
		# Do SendTargets method discovery
		#
		sendtargets_discovery(\&discovery_login_cb, $opt{d});
	} else {
		show_sessions();
	}
}
